# 1.6 1.13-和基岩版的命令方块方案

* 本内容仅提供方法 和TPA数据包文件本身事实上无关

## 双人方案

### 最终效果
双人方案适用于双人联机的情况下, 直接使用`/trigger tpa`传送到对方

### 手动输入部分
在开始搞命令方块之前 先新建以下记分项 （输入每行指令之前要加斜杠"/"）
```mcfunction
scoreboard objectives add tpa trigger
```

### 命令方块部分
设置以下命令方块: 
```mcfunction
scoreboard players enable @a tpa
tp @p[name="<玩家1>",scores={tpa=1..}] <玩家2> 
tp @p[name="<玩家2>",scores={tpa=1..}] <玩家1> 
scoreboard players set @a tpa 0
```

- 第一行写在一个 **循环 不受制约 保持开启** 的命令方块中
- 第二到第四行写在分别3个 **连锁 不受制约 保持开启** 的命令方块中

其中的尖括号"<>"包括的部分包括尖括号本身需要用真实的玩家名替代

放置为如图所示
![命令方块示意](../../assets/1.6_command_blocks.png)


## 多人方案

### 最终效果
多人方案适用于多人方案的情况下
每个玩家进入后会被系统分配id
如果要确定每个玩家的id 可以通过`/scoreboard objectives setdisplay sidebar id`查看 然后`/scoreboard objectives setdisplay sidebar`关闭查看
直接使用`/trigger tpa set <ID>`传送到对应ID的玩家

### 手动输入部分
在开始搞命令方块之前 先依次按行输入以下指令 （输入每行指令之前要加斜杠"/"）
```mcfunction
scoreboard objectives add tpa trigger
scoreboard objectives add id dummy
scoreboard players set #global_current id 0
```

### 命令方块部分

#### 1. 分配ID

放置为如图所示（最好保证图片为上北下南）
![命令方块示意](../../assets/1.6_command_blocks_.png)

命令方块A: 循环 不受制约 保持开启
```mcfunction
execute as @a unless score @s id = @s id run scoreboard players set @s id 0
```
命令方块B: 循环 不受制约 保持开启
```mcfunction
execute as @p[scores={id=0}] run scoreboard players add #global_current id 1
```

两个命令方块CD 顺着上一个放: 连锁 条件制约 保持开启
```
tellraw @a ["[TPA] ", {"selector": "@p[scores={id=0}] "}, " 分配了ID: ", {"score": {"name": "#global_current", "objective": "id"}}]
scoreboard players operation @p[scores={id=0}] id = #global_current id
```

#### 2. 处理传送

处理传送会有两个方案即*自闭链方案*和*枚举方案*
前者相对来说会复杂一点 但是可以理论上兼容无数玩家的传送
后者简单一点 但是只能兼容固定数量以下玩家的传送

##### 自闭链方案

该方案需要注意命令方块的空间排布和方向
同时错误的操作可能导致存档崩溃
所以请务必一步一步按照教程来

最终命令方块放置为如图所示（混凝土为标尺之用）
![命令方块示意](../../assets/1.6_command_blocks___.png)

挨着 命令方块A的南边放 向西的 命令方块E: *循环 不受制约 **红石控制***
```mcfunction
scoreboard players enable @a tpa
```

继续顺着 命令方块E的西面放 命令方块F,G,H,I,J,K,L,$M_0$和$N_0$ **连锁 不受制约 保持开启**
```mcfunction
tp @p[tag=reqer] @p[tag=target]
scoreboard players set @a[tag=reqer] tpa 0
tag @a remove reqer
tag @a remove target
tag @a remove notmatch
scoreboard players set #found tpa 0
tag @p[scores={tpa=1..}] add reqer
tag @p[tag=!notmatch] add target
execute if score @p[tag=target] id = @p[tag=reqer] tpa run scoreboard players set #found tpa 1
```

继续顺着 命令方块$N_0$的西面放 朝向南面的命令方块$O_0$ **连锁 不受制约 保持开启**
```mcfunction
execute if score #found tpa matches 0 run tag @p[tag=target] add notmatch
```

继续顺着 命令方块$O_0$的南面放 朝向东面的$P_0$ **连锁 不受制约 保持开启**
```mcfunction
execute if score #found tpa matches 0 run tag @a remove target
```

继续顺着 命令方块$P_0$的东面放 不需要填写指令的 朝向东面的$Q_0$ **连锁 不受制约 保持开启**
继续顺着 命令方块$Q_0$的东面放 朝向北面的$R_0$ **连锁 不受制约 保持开启**
```mcfunction
execute if score #found tpa matches 0 if entity @p[tag=!notmatch] run clone ~-2 ~ ~-3 ~ ~ ~-2 ~-2 ~ ~-1
```

然后人站在$O_0$(第一个开始拐弯的命令方块, 西北角的那个)上面正中间 聊天栏输入
```mcfunction
clone ~ ~-1 ~ ~2 ~-1 ~1 ~ ~-1 ~-2
```
然后身后会出现6个命令方块 根据对应关系会是$M_1$,$N_1$,$O_1$,$P_1$,$Q_1$,$R_1$

##### 枚举方案

```mcfunction
scoreboard players enable @a tpa
tp @a[scores={tpa=1}] @p[scores={id=1}]
tp @a[scores={tpa=2}] @p[scores={id=2}]
tp @a[scores={tpa=3}] @p[scores={id=3}]
tp @a[scores={tpa=4}] @p[scores={id=4}]
tp @a[scores={tpa=5}] @p[scores={id=5}]
tp @a[scores={tpa=6}] @p[scores={id=6}]
tp @a[scores={tpa=7}] @p[scores={id=7}]
tp @a[scores={tpa=8}] @p[scores={id=8}]
tp @a[scores={tpa=9}] @p[scores={id=9}]
tp @a[scores={tpa=10}] @p[scores={id=10}]
tp @a[scores={tpa=11}] @p[scores={id=11}]
tp @a[scores={tpa=12}] @p[scores={id=12}]
tp @a[scores={tpa=13}] @p[scores={id=13}]
tp @a[scores={tpa=14}] @p[scores={id=14}]
tp @a[scores={tpa=15}] @p[scores={id=15}]
tp @a[scores={tpa=16}] @p[scores={id=16}]
tp @a[scores={tpa=17}] @p[scores={id=17}]
tp @a[scores={tpa=18}] @p[scores={id=18}]
tp @a[scores={tpa=19}] @p[scores={id=19}]
tp @a[scores={tpa=20}] @p[scores={id=20}]
...
scoreboard players set @a tpa 0
```
枚举方案很简单 像如上模式进行填充就行 

如果工作量过大可以适当从末尾开始减少命令数 

如果要兼容更多人就按照这样继续往下加 但是再多人的话我会推荐你用自闭链尽管麻烦


最终命令方块放置为如图所示
![命令方块示意](../../assets/1.6_command_blocks__.png)
