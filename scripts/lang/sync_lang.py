import json
import yaml
from pathlib import Path
from collections import defaultdict
import re

# ========= 基本配置 =========

BASE_LANG = "zh_cn.yml"
CORE_LANGS = {"zh_cn", "en_us", "zh_tw", "ja_jp"}

ROOT = Path(__file__).resolve().parents[2]
LANG_DIR = ROOT / "scripts" / "lang"

CORE_TARGETS = [
    {
        "path": ROOT / "src/+mc1.15/data/tpa/functions/init_storage_lang.mcfunction",
        "pretty": False,
    },
    {
        "path": ROOT / "src/+mc1.20.2/format_1_20_5/data/tpa/functions/init_storage_lang.mcfunction",
        "pretty": True,
    },
    {
        "path": ROOT / "src/+mc1.20.2/data/tpa/function/init_storage_lang.mcfunction",
        "pretty": True,
    },
]

EXTRA_TARGETS = [
    {
        "path": ROOT / "src/lang_extra/data/tpa_extra/functions/init_storage_lang.mcfunction",
        "pretty": False,
    },
    {
        "path": ROOT / "src/lang_extra/data/tpa_extra/function/init_storage_lang.mcfunction",
        "pretty": True,
    },
]

# ========= 工具函数 =========

def load_yaml(path: Path) -> dict:
    if not path.exists():
        return {}
    with path.open("r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}

def fix_yaml_format(yaml_data: str):
    # 使用正则来匹配并修复值的格式（例如去掉不必要的引号）
    lines = yaml_data.split("\n")
    for i, line in enumerate(lines):
        if ':' in line:
            key, value = line.split(":", 1)
            # 如果值有引号，去掉它们
            if key.startswith('"') and key.endswith('"'):
                key = key[1:-1]
            # 重新拼接成键值对，确保值始终带引号
            lines[i] = f"{key}: {value}"
    return "\n".join(lines)

def save_yaml(path: Path, data: dict):
    with path.open("w", encoding="utf-8") as f:
        yaml.dump(data, f, allow_unicode=True, sort_keys=False, default_style='"')
    with path.open("r", encoding="utf-8") as f:
        yaml_content = f.read()
    with path.open("w", encoding="utf-8") as f:
        fixed = fix_yaml_format(yaml_content)
        f.write(fixed)

def escape_snbt_string(s: str) -> str:
    return s.replace("\\", "\\\\").replace('"', '\\"')

def snbt_compound(d: dict, pretty: bool) -> str:
    parts = []
    for k, v in d.items():
        if isinstance(v, str):
            parts.append(f'{k}: "{escape_snbt_string(v)}"')
        else:
            parts.append(f"{k}: {v}")

    if not pretty:
        return "{" + ", ".join(parts) + "}"

    return "{\\\n    " + ", \\\n    ".join(parts) + " \\\n}"

def snbt_list(items: list, pretty: bool) -> str:
    if not pretty:
        return "[{id:0}, " + ", ".join(items) + "]"

    return "[{id:0}, \\\n  " + ", \\\n  ".join(items) + " \\\n]"

def generate_mcfunction(lang_map: dict[str, dict], pretty: bool) -> str:
    compounds = []
    for lang, data in lang_map.items():
        compound = snbt_compound({"lang": lang, **data}, pretty)
        compounds.append(compound)

    snbt = snbt_list(compounds, pretty)
    header = "data modify storage tpa:tpa temp.lang set value "
    header += "\\\n" if pretty else ""
    return (
        f"{header}{snbt}\n"
        f"data modify storage tpa:tpa lang append from storage tpa:tpa temp.lang[]\n"
    )

# ========= 主流程 =========

base_path = LANG_DIR / BASE_LANG
base_data = load_yaml(base_path)

all_lang_files = [p for p in LANG_DIR.glob("*.yml") if p.name != BASE_LANG]

todo_translate = defaultdict(list)
all_lang_data = {}
all_lang_data["zh_cn"] = base_data

print("== 同步语言文件 ==")

for lang_file in all_lang_files:
    data: dict = load_yaml(lang_file)
    # change data to type dict
    if type(data) is not dict:
        data = data[0]

    lang_code = data["name"]

    for key, zh_value in base_data.items():
        if key not in data:
            data[key] = zh_value
            todo_translate[lang_code].append(key)

    save_yaml(lang_file, data)
    all_lang_data[lang_code] = data

    print(f"[{lang_file.name}] +{len(todo_translate[lang_code])} keys")

# ========= todo_translate.txt =========

if todo_translate:
    with open(ROOT / "todo_translate.txt", "w", encoding="utf-8") as f:
        f.write("# Generated by sync_lang.py\n\n")
        for lang, keys in todo_translate.items():
            if not keys:
                continue
            f.write(f"[{lang}]\n")
            for k in keys:
                f.write(k + "\n")
            f.write("\n")

# ========= 生成 mcfunction =========

core_langs = {}
extra_langs = {}

for lang, data in all_lang_data.items():
    if lang in CORE_LANGS:
        core_langs[lang] = data
    else:    
        extra_langs[lang] = data

print("\n== 生成 mcfunction ==")

for t in CORE_TARGETS:
    t["path"].parent.mkdir(parents=True, exist_ok=True)
    t["path"].write_text(generate_mcfunction(core_langs, t["pretty"]), encoding="utf-8")
    print(f"[CORE] {t['path']} 写入了 {list(core_langs)} 语言")

for t in EXTRA_TARGETS:
    t["path"].parent.mkdir(parents=True, exist_ok=True)
    t["path"].write_text(generate_mcfunction(extra_langs, t["pretty"]), encoding="utf-8")
    print(f"[EXTRA] {t['path']} 写入了 {list(extra_langs)} 语言")

print("\n✓ sync_lang.py 完成")
